
NERFMod.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  00000872  00000906  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000872  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000b  00800104  00800104  0000090a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000090a  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000090  00000000  00000000  0000093a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000acb  00000000  00000000  000009ca  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000230  00000000  00000000  00001495  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000407  00000000  00000000  000016c5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000180  00000000  00000000  00001acc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000024a  00000000  00000000  00001c4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000535  00000000  00000000  00001e96  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000080  00000000  00000000  000023cb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 48 00 	jmp	0x90	; 0x90 <__ctors_end>
   4:	0c 94 33 03 	jmp	0x666	; 0x666 <__vector_1>
   8:	0c 94 72 03 	jmp	0x6e4	; 0x6e4 <__vector_2>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 af 03 	jmp	0x75e	; 0x75e <__vector_4>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 ef 03 	jmp	0x7de	; 0x7de <__vector_6>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	df 00       	.word	0x00df	; ????
  7e:	e2 00       	.word	0x00e2	; ????
  80:	e5 00       	.word	0x00e5	; ????
  82:	e8 00       	.word	0x00e8	; ????
  84:	eb 00       	.word	0x00eb	; ????
  86:	ee 00       	.word	0x00ee	; ????
  88:	f1 00       	.word	0x00f1	; ????
  8a:	f4 00       	.word	0x00f4	; ????
  8c:	f7 00       	.word	0x00f7	; ????
  8e:	fa 00       	.word	0x00fa	; ????

00000090 <__ctors_end>:
  90:	11 24       	eor	r1, r1
  92:	1f be       	out	0x3f, r1	; 63
  94:	cf ef       	ldi	r28, 0xFF	; 255
  96:	d0 e1       	ldi	r29, 0x10	; 16
  98:	de bf       	out	0x3e, r29	; 62
  9a:	cd bf       	out	0x3d, r28	; 61

0000009c <__do_copy_data>:
  9c:	11 e0       	ldi	r17, 0x01	; 1
  9e:	a0 e0       	ldi	r26, 0x00	; 0
  a0:	b1 e0       	ldi	r27, 0x01	; 1
  a2:	e2 e7       	ldi	r30, 0x72	; 114
  a4:	f8 e0       	ldi	r31, 0x08	; 8
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x10>
  a8:	05 90       	lpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a4 30       	cpi	r26, 0x04	; 4
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0xc>

000000b2 <__do_clear_bss>:
  b2:	21 e0       	ldi	r18, 0x01	; 1
  b4:	a4 e0       	ldi	r26, 0x04	; 4
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	af 30       	cpi	r26, 0x0F	; 15
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 a9 02 	call	0x552	; 0x552 <main>
  c6:	0c 94 37 04 	jmp	0x86e	; 0x86e <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <init>:
}

void init()
{
	//PORTS
	DDRA = 0b01000000;		//except Pin 6 all Pin as Input
  ce:	80 e4       	ldi	r24, 0x40	; 64
  d0:	81 b9       	out	0x01, r24	; 1
	PORTA = 0b11111111;		//activate PullUp for all Input, Output to VCC
  d2:	8f ef       	ldi	r24, 0xFF	; 255
  d4:	82 b9       	out	0x02, r24	; 2
	  //Latch
	DDRB = 0b11111111;		//all Pin as Output
  d6:	84 b9       	out	0x04, r24	; 4
	PORTB = 0b00000000;		//all Pin to GND
  d8:	15 b8       	out	0x05, r1	; 5
	
	DDRC = 0b01111111;		//except Pin 7 all Pin as Output
  da:	8f e7       	ldi	r24, 0x7F	; 127
  dc:	87 b9       	out	0x07, r24	; 7
	PORTC = 0b10000000;		//activate PullUp for Pin 7, Output to GND
  de:	80 e8       	ldi	r24, 0x80	; 128
  e0:	88 b9       	out	0x08, r24	; 8
	
	DDRD = 0b11110011;		//except Pin 2,3 all Pin as Output
  e2:	83 ef       	ldi	r24, 0xF3	; 243
  e4:	8a b9       	out	0x0a, r24	; 10
	PORTD = 0b00001111;		//activate PullUp for all Input, Output to GND
  e6:	8f e0       	ldi	r24, 0x0F	; 15
  e8:	8b b9       	out	0x0b, r24	; 11
	
	//EXTERNAL INTERRUPT
	EIMSK |= (1 << INT0);							//activates the INT0 Interrupt
  ea:	e8 9a       	sbi	0x1d, 0	; 29
	EIMSK |= (1 << INT1);							//activates the INT1 Interrupt
  ec:	e9 9a       	sbi	0x1d, 1	; 29
	EICRA |= (1 << ISC11) | (1 << ISC01);			//sets INT1 to falling edge 
  ee:	e9 e6       	ldi	r30, 0x69	; 105
  f0:	f0 e0       	ldi	r31, 0x00	; 0
  f2:	80 81       	ld	r24, Z
  f4:	8a 60       	ori	r24, 0x0A	; 10
  f6:	80 83       	st	Z, r24
	
	//EXTERNAL PC-INTERRUPT
	PCMSK0 |= ((1<<PCINT0) | (1<<PCINT1) | (1<<PCINT2));	//set Port A Pin 0,1,2 to External Interrupt
  f8:	eb e6       	ldi	r30, 0x6B	; 107
  fa:	f0 e0       	ldi	r31, 0x00	; 0
  fc:	80 81       	ld	r24, Z
  fe:	87 60       	ori	r24, 0x07	; 7
 100:	80 83       	st	Z, r24
	PCMSK2 |= (1 << PCINT7);						//set Port C Pin 7 to External Interrupt
 102:	ed e6       	ldi	r30, 0x6D	; 109
 104:	f0 e0       	ldi	r31, 0x00	; 0
 106:	80 81       	ld	r24, Z
 108:	80 68       	ori	r24, 0x80	; 128
 10a:	80 83       	st	Z, r24
	PCICR |= ((1 << PCIE0) | (1 << PCIE2));			//activate Port A,C External Interrupt
 10c:	e8 e6       	ldi	r30, 0x68	; 104
 10e:	f0 e0       	ldi	r31, 0x00	; 0
 110:	80 81       	ld	r24, Z
 112:	85 60       	ori	r24, 0x05	; 5
 114:	80 83       	st	Z, r24
	
	//PWM Push
	TCCR2A |= (1 << WGM20);							//select phase correct PWM
 116:	e0 eb       	ldi	r30, 0xB0	; 176
 118:	f0 e0       	ldi	r31, 0x00	; 0
 11a:	80 81       	ld	r24, Z
 11c:	81 60       	ori	r24, 0x01	; 1
 11e:	80 83       	st	Z, r24
	OCR2A = 200;									//sets the rate of Output
 120:	88 ec       	ldi	r24, 0xC8	; 200
 122:	80 93 b3 00 	sts	0x00B3, r24
	
	//PMW FlyWheels
	TCCR1A |= (1 << WGM10) | (1 << COM1A1);			//select phase correct PWM, Pin D5
 126:	e0 e8       	ldi	r30, 0x80	; 128
 128:	f0 e0       	ldi	r31, 0x00	; 0
 12a:	80 81       	ld	r24, Z
 12c:	81 68       	ori	r24, 0x81	; 129
 12e:	80 83       	st	Z, r24
	OCR1AH = 0x00;
 130:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = 0x00;									//set PWM to zero
 134:	10 92 88 00 	sts	0x0088, r1
	
	//ADC
	ADMUX |= (1 << REFS0);							//select AVCC as reference Voltage
 138:	ec e7       	ldi	r30, 0x7C	; 124
 13a:	f0 e0       	ldi	r31, 0x00	; 0
 13c:	80 81       	ld	r24, Z
 13e:	80 64       	ori	r24, 0x40	; 64
 140:	80 83       	st	Z, r24
	ADMUX |= ((1<< MUX0) | (1 << MUX1) | (1 << MUX2));	//ADC on Pin 7
 142:	80 81       	ld	r24, Z
 144:	87 60       	ori	r24, 0x07	; 7
 146:	80 83       	st	Z, r24
	ADCSRA |= (1 << ADEN);							//enables the ADC
 148:	ea e7       	ldi	r30, 0x7A	; 122
 14a:	f0 e0       	ldi	r31, 0x00	; 0
 14c:	80 81       	ld	r24, Z
 14e:	80 68       	ori	r24, 0x80	; 128
 150:	80 83       	st	Z, r24
	ADCSRA |= ((1 << ADPS2) | (1 << ADPS1));		//set clock division factor to 64
 152:	80 81       	ld	r24, Z
 154:	86 60       	ori	r24, 0x06	; 6
 156:	80 83       	st	Z, r24
	
	//POWER REDUCTION
	PRR0 |= (1 << PRTWI);							//deactivates TWI
 158:	e4 e6       	ldi	r30, 0x64	; 100
 15a:	f0 e0       	ldi	r31, 0x00	; 0
 15c:	80 81       	ld	r24, Z
 15e:	80 68       	ori	r24, 0x80	; 128
 160:	80 83       	st	Z, r24
	PRR0 |= (1 << PRUSART1);						//deactivates USART1
 162:	80 81       	ld	r24, Z
 164:	80 61       	ori	r24, 0x10	; 16
 166:	80 83       	st	Z, r24
	PRR0 |= (1 << PRUSART0);						//deactivates USART0
 168:	80 81       	ld	r24, Z
 16a:	82 60       	ori	r24, 0x02	; 2
 16c:	80 83       	st	Z, r24
	
	sei();											//activate Global Interrupt
 16e:	78 94       	sei
 170:	08 95       	ret

00000172 <getMag>:
{
	return 1;
}
int getMag()
{
	if(!(PINA & (1 << PINA5)))			//Pin 5 GND
 172:	05 99       	sbic	0x00, 5	; 0
 174:	0d c0       	rjmp	.+26     	; 0x190 <getMag+0x1e>
	{
		if(!(PINA & ((1 << PINA3) | (1 << PINA4))))		return 6;		//Pin 3,4 GND
 176:	80 b1       	in	r24, 0x00	; 0
 178:	88 71       	andi	r24, 0x18	; 24
 17a:	69 f0       	breq	.+26     	; 0x196 <getMag+0x24>
		if(!(PINA & (1 << PINA3)))						return 12;		//Pin 3 GND, Pin 4 VCC
 17c:	03 9b       	sbis	0x00, 3	; 0
 17e:	0e c0       	rjmp	.+28     	; 0x19c <getMag+0x2a>
		if(!(PINA & (1 << PINA4)))						return 18;		//Pin 3 VCC, Pin 4 GND
 180:	04 9b       	sbis	0x00, 4	; 0
 182:	0f c0       	rjmp	.+30     	; 0x1a2 <getMag+0x30>
		if(PINA & ((1 << PINA3) | (1 << PINA4)))		return 25;		//Pin 3,4 VCC
 184:	80 b1       	in	r24, 0x00	; 0
 186:	88 71       	andi	r24, 0x18	; 24
 188:	79 f4       	brne	.+30     	; 0x1a8 <getMag+0x36>
	}
	return -1;
 18a:	8f ef       	ldi	r24, 0xFF	; 255
 18c:	9f ef       	ldi	r25, 0xFF	; 255
 18e:	08 95       	ret
 190:	8f ef       	ldi	r24, 0xFF	; 255
 192:	9f ef       	ldi	r25, 0xFF	; 255
 194:	08 95       	ret
}
int getMag()
{
	if(!(PINA & (1 << PINA5)))			//Pin 5 GND
	{
		if(!(PINA & ((1 << PINA3) | (1 << PINA4))))		return 6;		//Pin 3,4 GND
 196:	86 e0       	ldi	r24, 0x06	; 6
 198:	90 e0       	ldi	r25, 0x00	; 0
 19a:	08 95       	ret
		if(!(PINA & (1 << PINA3)))						return 12;		//Pin 3 GND, Pin 4 VCC
 19c:	8c e0       	ldi	r24, 0x0C	; 12
 19e:	90 e0       	ldi	r25, 0x00	; 0
 1a0:	08 95       	ret
		if(!(PINA & (1 << PINA4)))						return 18;		//Pin 3 VCC, Pin 4 GND
 1a2:	82 e1       	ldi	r24, 0x12	; 18
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	08 95       	ret
		if(PINA & ((1 << PINA3) | (1 << PINA4)))		return 25;		//Pin 3,4 VCC
 1a8:	89 e1       	ldi	r24, 0x19	; 25
 1aa:	90 e0       	ldi	r25, 0x00	; 0
	}
	return -1;
}
 1ac:	08 95       	ret

000001ae <displayLE>:
		
	}
}
void displayLE(int display)
{
	switch (display)
 1ae:	8a 30       	cpi	r24, 0x0A	; 10
 1b0:	91 05       	cpc	r25, r1
 1b2:	10 f5       	brcc	.+68     	; 0x1f8 <displayLE+0x4a>
 1b4:	fc 01       	movw	r30, r24
 1b6:	e2 5c       	subi	r30, 0xC2	; 194
 1b8:	ff 4f       	sbci	r31, 0xFF	; 255
 1ba:	0c 94 31 04 	jmp	0x862	; 0x862 <__tablejump2__>
	{
		case 0:
		{
			PORTB = 238;
 1be:	8e ee       	ldi	r24, 0xEE	; 238
 1c0:	85 b9       	out	0x05, r24	; 5
			break;
 1c2:	08 95       	ret
		}
		case 1:
		{
			PORTB = 96;
 1c4:	80 e6       	ldi	r24, 0x60	; 96
 1c6:	85 b9       	out	0x05, r24	; 5
			break;
 1c8:	08 95       	ret
		}
		case 2:
		{
			PORTB = 205;
 1ca:	8d ec       	ldi	r24, 0xCD	; 205
 1cc:	85 b9       	out	0x05, r24	; 5
			break;
 1ce:	08 95       	ret
		}
		case 3:
		{
			PORTB = 233;
 1d0:	89 ee       	ldi	r24, 0xE9	; 233
 1d2:	85 b9       	out	0x05, r24	; 5
			break;
 1d4:	08 95       	ret
		}case 4:
		{
			PORTB = 99;
 1d6:	83 e6       	ldi	r24, 0x63	; 99
 1d8:	85 b9       	out	0x05, r24	; 5
			break;
 1da:	08 95       	ret
		}
		case 5:
		{
			PORTB = 171;
 1dc:	8b ea       	ldi	r24, 0xAB	; 171
 1de:	85 b9       	out	0x05, r24	; 5
			break;
 1e0:	08 95       	ret
		}
		case 6:
		{
			PORTB = 175;
 1e2:	8f ea       	ldi	r24, 0xAF	; 175
 1e4:	85 b9       	out	0x05, r24	; 5
			break;
 1e6:	08 95       	ret
		}
		case 7:
		{
			PORTB = 224;
 1e8:	80 ee       	ldi	r24, 0xE0	; 224
 1ea:	85 b9       	out	0x05, r24	; 5
			break;
 1ec:	08 95       	ret
		}
		case 8:
		{
			PORTB = 239;
 1ee:	8f ee       	ldi	r24, 0xEF	; 239
 1f0:	85 b9       	out	0x05, r24	; 5
			break;
 1f2:	08 95       	ret
		}
		case 9:
		{
			PORTB = 235;
 1f4:	8b ee       	ldi	r24, 0xEB	; 235
 1f6:	85 b9       	out	0x05, r24	; 5
 1f8:	08 95       	ret

000001fa <setSpeed>:
	LEEnabel(3);
}

void setSpeed(int speed, char motorOn)
{
	if (motorOn == 0)  
 1fa:	61 11       	cpse	r22, r1
 1fc:	06 c0       	rjmp	.+12     	; 0x20a <setSpeed+0x10>
	{
		TCCR1B &= ~(1 << CS10);				//PWM off
 1fe:	e1 e8       	ldi	r30, 0x81	; 129
 200:	f0 e0       	ldi	r31, 0x00	; 0
 202:	80 81       	ld	r24, Z
 204:	8e 7f       	andi	r24, 0xFE	; 254
 206:	80 83       	st	Z, r24
 208:	08 95       	ret
	}
	if (motorOn == 1)
 20a:	61 30       	cpi	r22, 0x01	; 1
 20c:	f9 f4       	brne	.+62     	; 0x24c <setSpeed+0x52>
	{
		TCCR1B |= (1 << CS10);				//PWM on
 20e:	e1 e8       	ldi	r30, 0x81	; 129
 210:	f0 e0       	ldi	r31, 0x00	; 0
 212:	20 81       	ld	r18, Z
 214:	21 60       	ori	r18, 0x01	; 1
 216:	20 83       	st	Z, r18
 		if(speed == 1) OCR1AL = 50;			//set PWM to ...
 218:	81 30       	cpi	r24, 0x01	; 1
 21a:	91 05       	cpc	r25, r1
 21c:	21 f4       	brne	.+8      	; 0x226 <setSpeed+0x2c>
 21e:	22 e3       	ldi	r18, 0x32	; 50
 220:	20 93 88 00 	sts	0x0088, r18
 224:	0e c0       	rjmp	.+28     	; 0x242 <setSpeed+0x48>
 		if(speed == 2) OCR1AL = 75;
 226:	82 30       	cpi	r24, 0x02	; 2
 228:	91 05       	cpc	r25, r1
 22a:	21 f4       	brne	.+8      	; 0x234 <setSpeed+0x3a>
 22c:	8b e4       	ldi	r24, 0x4B	; 75
 22e:	80 93 88 00 	sts	0x0088, r24
 232:	08 95       	ret
		if(speed == 3) OCR1AL = 125;
 234:	83 30       	cpi	r24, 0x03	; 3
 236:	91 05       	cpc	r25, r1
 238:	21 f4       	brne	.+8      	; 0x242 <setSpeed+0x48>
 23a:	8d e7       	ldi	r24, 0x7D	; 125
 23c:	80 93 88 00 	sts	0x0088, r24
 240:	08 95       	ret
		if(speed == 4) OCR1AL = 255;
 242:	04 97       	sbiw	r24, 0x04	; 4
 244:	19 f4       	brne	.+6      	; 0x24c <setSpeed+0x52>
 246:	8f ef       	ldi	r24, 0xFF	; 255
 248:	80 93 88 00 	sts	0x0088, r24
 24c:	08 95       	ret

0000024e <LEEnabel>:
	}
}

void LEEnabel(int LENumber)
{
	if (LENumber == 1)	PORTD &= ~(1 << PORTD0);
 24e:	81 30       	cpi	r24, 0x01	; 1
 250:	91 05       	cpc	r25, r1
 252:	11 f4       	brne	.+4      	; 0x258 <LEEnabel+0xa>
 254:	58 98       	cbi	0x0b, 0	; 11
 256:	08 95       	ret
	if (LENumber == 2)	PORTD &= ~(1 << PORTD1);
 258:	82 30       	cpi	r24, 0x02	; 2
 25a:	91 05       	cpc	r25, r1
 25c:	11 f4       	brne	.+4      	; 0x262 <LEEnabel+0x14>
 25e:	59 98       	cbi	0x0b, 1	; 11
 260:	08 95       	ret
	if (LENumber == 3)  PORTA &= ~(1 << PORTA6);
 262:	03 97       	sbiw	r24, 0x03	; 3
 264:	09 f4       	brne	.+2      	; 0x268 <LEEnabel+0x1a>
 266:	16 98       	cbi	0x02, 6	; 2
 268:	08 95       	ret

0000026a <LEDisable>:
}
void LEDisable(int LENumber)
{
	if (LENumber == 1)  PORTD |= (1 << PORTD0);
 26a:	81 30       	cpi	r24, 0x01	; 1
 26c:	91 05       	cpc	r25, r1
 26e:	11 f4       	brne	.+4      	; 0x274 <LEDisable+0xa>
 270:	58 9a       	sbi	0x0b, 0	; 11
 272:	08 c0       	rjmp	.+16     	; 0x284 <LEDisable+0x1a>
	if (LENumber == 2)	PORTD |= (1 << PORTD1);
 274:	82 30       	cpi	r24, 0x02	; 2
 276:	91 05       	cpc	r25, r1
 278:	11 f4       	brne	.+4      	; 0x27e <LEDisable+0x14>
 27a:	59 9a       	sbi	0x0b, 1	; 11
 27c:	03 c0       	rjmp	.+6      	; 0x284 <LEDisable+0x1a>
	if (LENumber == 3)	PORTA |= (1 << PORTA6);
 27e:	03 97       	sbiw	r24, 0x03	; 3
 280:	09 f4       	brne	.+2      	; 0x284 <LEDisable+0x1a>
 282:	16 9a       	sbi	0x02, 6	; 2
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 284:	89 e6       	ldi	r24, 0x69	; 105
 286:	98 e1       	ldi	r25, 0x18	; 24
 288:	01 97       	sbiw	r24, 0x01	; 1
 28a:	f1 f7       	brne	.-4      	; 0x288 <LEDisable+0x1e>
 28c:	00 c0       	rjmp	.+0      	; 0x28e <LEDisable+0x24>
 28e:	00 00       	nop
 290:	08 95       	ret

00000292 <display>:
	}
	return -1;
}

void display(int display)
{
 292:	cf 93       	push	r28
 294:	df 93       	push	r29
 296:	ec 01       	movw	r28, r24
	if (display == -2)
 298:	ce 3f       	cpi	r28, 0xFE	; 254
 29a:	8f ef       	ldi	r24, 0xFF	; 255
 29c:	d8 07       	cpc	r29, r24
 29e:	99 f4       	brne	.+38     	; 0x2c6 <display+0x34>
	{
		PORTB = 255;
 2a0:	8f ef       	ldi	r24, 0xFF	; 255
 2a2:	85 b9       	out	0x05, r24	; 5
		
		LEDisable(1);
 2a4:	81 e0       	ldi	r24, 0x01	; 1
 2a6:	90 e0       	ldi	r25, 0x00	; 0
 2a8:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
		LEDisable(2);
 2ac:	82 e0       	ldi	r24, 0x02	; 2
 2ae:	90 e0       	ldi	r25, 0x00	; 0
 2b0:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
		LEEnabel(1);
 2b4:	81 e0       	ldi	r24, 0x01	; 1
 2b6:	90 e0       	ldi	r25, 0x00	; 0
 2b8:	0e 94 27 01 	call	0x24e	; 0x24e <LEEnabel>
		LEEnabel(2);
 2bc:	82 e0       	ldi	r24, 0x02	; 2
 2be:	90 e0       	ldi	r25, 0x00	; 0
 2c0:	0e 94 27 01 	call	0x24e	; 0x24e <LEEnabel>
 2c4:	b8 c0       	rjmp	.+368    	; 0x436 <display+0x1a4>
	}
	else if (display == -1)
 2c6:	cf 3f       	cpi	r28, 0xFF	; 255
 2c8:	8f ef       	ldi	r24, 0xFF	; 255
 2ca:	d8 07       	cpc	r29, r24
 2cc:	99 f4       	brne	.+38     	; 0x2f4 <display+0x62>
	{
		PORTB = 16;
 2ce:	80 e1       	ldi	r24, 0x10	; 16
 2d0:	85 b9       	out	0x05, r24	; 5
		LEDisable(1);
 2d2:	81 e0       	ldi	r24, 0x01	; 1
 2d4:	90 e0       	ldi	r25, 0x00	; 0
 2d6:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
		LEDisable(2);
 2da:	82 e0       	ldi	r24, 0x02	; 2
 2dc:	90 e0       	ldi	r25, 0x00	; 0
 2de:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
		LEEnabel(1);
 2e2:	81 e0       	ldi	r24, 0x01	; 1
 2e4:	90 e0       	ldi	r25, 0x00	; 0
 2e6:	0e 94 27 01 	call	0x24e	; 0x24e <LEEnabel>
		LEEnabel(2);
 2ea:	82 e0       	ldi	r24, 0x02	; 2
 2ec:	90 e0       	ldi	r25, 0x00	; 0
 2ee:	0e 94 27 01 	call	0x24e	; 0x24e <LEEnabel>
 2f2:	a1 c0       	rjmp	.+322    	; 0x436 <display+0x1a4>
	}
	else
	{
		if(display < 10)
 2f4:	ca 30       	cpi	r28, 0x0A	; 10
 2f6:	d1 05       	cpc	r29, r1
 2f8:	44 f4       	brge	.+16     	; 0x30a <display+0x78>
		{
			displayLE(0);
 2fa:	80 e0       	ldi	r24, 0x00	; 0
 2fc:	90 e0       	ldi	r25, 0x00	; 0
 2fe:	0e 94 d7 00 	call	0x1ae	; 0x1ae <displayLE>
			LEDisable(1);
 302:	81 e0       	ldi	r24, 0x01	; 1
 304:	90 e0       	ldi	r25, 0x00	; 0
 306:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
		}
		if(display >= 100)
 30a:	c4 36       	cpi	r28, 0x64	; 100
 30c:	d1 05       	cpc	r29, r1
 30e:	34 f0       	brlt	.+12     	; 0x31c <display+0x8a>
		{
			PORTB = 0b00010000;	
 310:	80 e1       	ldi	r24, 0x10	; 16
 312:	85 b9       	out	0x05, r24	; 5
			LEDisable(1);
 314:	81 e0       	ldi	r24, 0x01	; 1
 316:	90 e0       	ldi	r25, 0x00	; 0
 318:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
		}
		if(display >= 90)
 31c:	ca 35       	cpi	r28, 0x5A	; 90
 31e:	d1 05       	cpc	r29, r1
 320:	54 f0       	brlt	.+20     	; 0x336 <display+0xa4>
		{
			displayLE(9);
 322:	89 e0       	ldi	r24, 0x09	; 9
 324:	90 e0       	ldi	r25, 0x00	; 0
 326:	0e 94 d7 00 	call	0x1ae	; 0x1ae <displayLE>
			LEDisable(1);
 32a:	81 e0       	ldi	r24, 0x01	; 1
 32c:	90 e0       	ldi	r25, 0x00	; 0
 32e:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
			display -= 90;
 332:	ca 55       	subi	r28, 0x5A	; 90
 334:	d1 09       	sbc	r29, r1
		}
		if(display >= 80)
 336:	c0 35       	cpi	r28, 0x50	; 80
 338:	d1 05       	cpc	r29, r1
 33a:	54 f0       	brlt	.+20     	; 0x350 <display+0xbe>
		{
			displayLE(8);
 33c:	88 e0       	ldi	r24, 0x08	; 8
 33e:	90 e0       	ldi	r25, 0x00	; 0
 340:	0e 94 d7 00 	call	0x1ae	; 0x1ae <displayLE>
			LEDisable(1);
 344:	81 e0       	ldi	r24, 0x01	; 1
 346:	90 e0       	ldi	r25, 0x00	; 0
 348:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
			display -= 80;
 34c:	c0 55       	subi	r28, 0x50	; 80
 34e:	d1 09       	sbc	r29, r1
		}
		if(display >= 70)
 350:	c6 34       	cpi	r28, 0x46	; 70
 352:	d1 05       	cpc	r29, r1
 354:	54 f0       	brlt	.+20     	; 0x36a <display+0xd8>
		{
			displayLE(7);
 356:	87 e0       	ldi	r24, 0x07	; 7
 358:	90 e0       	ldi	r25, 0x00	; 0
 35a:	0e 94 d7 00 	call	0x1ae	; 0x1ae <displayLE>
			LEDisable(1);
 35e:	81 e0       	ldi	r24, 0x01	; 1
 360:	90 e0       	ldi	r25, 0x00	; 0
 362:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
			display -= 70;
 366:	c6 54       	subi	r28, 0x46	; 70
 368:	d1 09       	sbc	r29, r1
		}
		if(display >= 60)
 36a:	cc 33       	cpi	r28, 0x3C	; 60
 36c:	d1 05       	cpc	r29, r1
 36e:	4c f0       	brlt	.+18     	; 0x382 <display+0xf0>
		{
			displayLE(6);
 370:	86 e0       	ldi	r24, 0x06	; 6
 372:	90 e0       	ldi	r25, 0x00	; 0
 374:	0e 94 d7 00 	call	0x1ae	; 0x1ae <displayLE>
			LEDisable(1);
 378:	81 e0       	ldi	r24, 0x01	; 1
 37a:	90 e0       	ldi	r25, 0x00	; 0
 37c:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
			display -= 60;
 380:	ec 97       	sbiw	r28, 0x3c	; 60
		}
		if(display >= 50)
 382:	c2 33       	cpi	r28, 0x32	; 50
 384:	d1 05       	cpc	r29, r1
 386:	4c f0       	brlt	.+18     	; 0x39a <display+0x108>
		{
			displayLE(5);
 388:	85 e0       	ldi	r24, 0x05	; 5
 38a:	90 e0       	ldi	r25, 0x00	; 0
 38c:	0e 94 d7 00 	call	0x1ae	; 0x1ae <displayLE>
			LEDisable(1);
 390:	81 e0       	ldi	r24, 0x01	; 1
 392:	90 e0       	ldi	r25, 0x00	; 0
 394:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
			display -= 50;
 398:	e2 97       	sbiw	r28, 0x32	; 50
		}
		if(display >= 40)
 39a:	c8 32       	cpi	r28, 0x28	; 40
 39c:	d1 05       	cpc	r29, r1
 39e:	4c f0       	brlt	.+18     	; 0x3b2 <display+0x120>
		{
			displayLE(4);
 3a0:	84 e0       	ldi	r24, 0x04	; 4
 3a2:	90 e0       	ldi	r25, 0x00	; 0
 3a4:	0e 94 d7 00 	call	0x1ae	; 0x1ae <displayLE>
			LEDisable(1);
 3a8:	81 e0       	ldi	r24, 0x01	; 1
 3aa:	90 e0       	ldi	r25, 0x00	; 0
 3ac:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
			display -= 40;
 3b0:	a8 97       	sbiw	r28, 0x28	; 40
		}
		if(display >= 30)
 3b2:	ce 31       	cpi	r28, 0x1E	; 30
 3b4:	d1 05       	cpc	r29, r1
 3b6:	c4 f0       	brlt	.+48     	; 0x3e8 <display+0x156>
		{
			displayLE(3);
 3b8:	83 e0       	ldi	r24, 0x03	; 3
 3ba:	90 e0       	ldi	r25, 0x00	; 0
 3bc:	0e 94 d7 00 	call	0x1ae	; 0x1ae <displayLE>
			LEDisable(1);
 3c0:	81 e0       	ldi	r24, 0x01	; 1
 3c2:	90 e0       	ldi	r25, 0x00	; 0
 3c4:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
			display -= 30;
 3c8:	ce 01       	movw	r24, r28
 3ca:	4e 97       	sbiw	r24, 0x1e	; 30
		}
		if(display >= 30)
 3cc:	8e 31       	cpi	r24, 0x1E	; 30
 3ce:	91 05       	cpc	r25, r1
 3d0:	54 f0       	brlt	.+20     	; 0x3e6 <display+0x154>
		{
			displayLE(3);
 3d2:	83 e0       	ldi	r24, 0x03	; 3
 3d4:	90 e0       	ldi	r25, 0x00	; 0
 3d6:	0e 94 d7 00 	call	0x1ae	; 0x1ae <displayLE>
			LEDisable(1);
 3da:	81 e0       	ldi	r24, 0x01	; 1
 3dc:	90 e0       	ldi	r25, 0x00	; 0
 3de:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
			display -= 30;
 3e2:	ec 97       	sbiw	r28, 0x3c	; 60
 3e4:	01 c0       	rjmp	.+2      	; 0x3e8 <display+0x156>
		}
		if(display >= 30)
		{
			displayLE(3);
			LEDisable(1);
			display -= 30;
 3e6:	ec 01       	movw	r28, r24
		{
			displayLE(3);
			LEDisable(1);
			display -= 30;
		}
		if(display >= 20)
 3e8:	c4 31       	cpi	r28, 0x14	; 20
 3ea:	d1 05       	cpc	r29, r1
 3ec:	4c f0       	brlt	.+18     	; 0x400 <display+0x16e>
		{
			displayLE(2);
 3ee:	82 e0       	ldi	r24, 0x02	; 2
 3f0:	90 e0       	ldi	r25, 0x00	; 0
 3f2:	0e 94 d7 00 	call	0x1ae	; 0x1ae <displayLE>
			LEDisable(1);
 3f6:	81 e0       	ldi	r24, 0x01	; 1
 3f8:	90 e0       	ldi	r25, 0x00	; 0
 3fa:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
			display -= 20;
 3fe:	64 97       	sbiw	r28, 0x14	; 20
		}
		if(display >= 10)
 400:	ca 30       	cpi	r28, 0x0A	; 10
 402:	d1 05       	cpc	r29, r1
 404:	4c f0       	brlt	.+18     	; 0x418 <display+0x186>
		{
			displayLE(1);
 406:	81 e0       	ldi	r24, 0x01	; 1
 408:	90 e0       	ldi	r25, 0x00	; 0
 40a:	0e 94 d7 00 	call	0x1ae	; 0x1ae <displayLE>
			LEDisable(1);
 40e:	81 e0       	ldi	r24, 0x01	; 1
 410:	90 e0       	ldi	r25, 0x00	; 0
 412:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
			display -= 10;
 416:	2a 97       	sbiw	r28, 0x0a	; 10
		}
		
		LEEnabel(1);
 418:	81 e0       	ldi	r24, 0x01	; 1
 41a:	90 e0       	ldi	r25, 0x00	; 0
 41c:	0e 94 27 01 	call	0x24e	; 0x24e <LEEnabel>
		
		displayLE(display);
 420:	ce 01       	movw	r24, r28
 422:	0e 94 d7 00 	call	0x1ae	; 0x1ae <displayLE>
		LEDisable(2);
 426:	82 e0       	ldi	r24, 0x02	; 2
 428:	90 e0       	ldi	r25, 0x00	; 0
 42a:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
		LEEnabel(2);
 42e:	82 e0       	ldi	r24, 0x02	; 2
 430:	90 e0       	ldi	r25, 0x00	; 0
 432:	0e 94 27 01 	call	0x24e	; 0x24e <LEEnabel>
		
	}
}
 436:	df 91       	pop	r29
 438:	cf 91       	pop	r28
 43a:	08 95       	ret

0000043c <displaySpeed>:
		}
	}
}
void displaySpeed(int speed, char motorOn)
{
	if (motorOn == 0) PORTB = 0b00000000;
 43c:	61 11       	cpse	r22, r1
 43e:	02 c0       	rjmp	.+4      	; 0x444 <displaySpeed+0x8>
 440:	15 b8       	out	0x05, r1	; 5
 442:	18 c0       	rjmp	.+48     	; 0x474 <displaySpeed+0x38>
	if (motorOn == 1)
 444:	61 30       	cpi	r22, 0x01	; 1
 446:	b1 f4       	brne	.+44     	; 0x474 <displaySpeed+0x38>
	{
		if(speed == 1)	PORTB = 0b11000000;
 448:	81 30       	cpi	r24, 0x01	; 1
 44a:	91 05       	cpc	r25, r1
 44c:	19 f4       	brne	.+6      	; 0x454 <displaySpeed+0x18>
 44e:	20 ec       	ldi	r18, 0xC0	; 192
 450:	25 b9       	out	0x05, r18	; 5
 452:	0c c0       	rjmp	.+24     	; 0x46c <displaySpeed+0x30>
		if(speed == 2)	PORTB = 0b11110000;
 454:	82 30       	cpi	r24, 0x02	; 2
 456:	91 05       	cpc	r25, r1
 458:	19 f4       	brne	.+6      	; 0x460 <displaySpeed+0x24>
 45a:	80 ef       	ldi	r24, 0xF0	; 240
 45c:	85 b9       	out	0x05, r24	; 5
 45e:	0a c0       	rjmp	.+20     	; 0x474 <displaySpeed+0x38>
		if(speed == 3)	PORTB = 0b11111100;
 460:	83 30       	cpi	r24, 0x03	; 3
 462:	91 05       	cpc	r25, r1
 464:	19 f4       	brne	.+6      	; 0x46c <displaySpeed+0x30>
 466:	8c ef       	ldi	r24, 0xFC	; 252
 468:	85 b9       	out	0x05, r24	; 5
 46a:	04 c0       	rjmp	.+8      	; 0x474 <displaySpeed+0x38>
		if(speed == 4)	PORTB = 0b11111111;
 46c:	04 97       	sbiw	r24, 0x04	; 4
 46e:	11 f4       	brne	.+4      	; 0x474 <displaySpeed+0x38>
 470:	8f ef       	ldi	r24, 0xFF	; 255
 472:	85 b9       	out	0x05, r24	; 5
	}
	LEDisable(3);
 474:	83 e0       	ldi	r24, 0x03	; 3
 476:	90 e0       	ldi	r25, 0x00	; 0
 478:	0e 94 35 01 	call	0x26a	; 0x26a <LEDisable>
	LEEnabel(3);
 47c:	83 e0       	ldi	r24, 0x03	; 3
 47e:	90 e0       	ldi	r25, 0x00	; 0
 480:	0e 94 27 01 	call	0x24e	; 0x24e <LEEnabel>
 484:	08 95       	ret

00000486 <startUp>:
	
	sei();											//activate Global Interrupt
	
}
void startUp ()
{
 486:	cf 93       	push	r28
 488:	df 93       	push	r29
	display(-2);
 48a:	8e ef       	ldi	r24, 0xFE	; 254
 48c:	9f ef       	ldi	r25, 0xFF	; 255
 48e:	0e 94 49 01 	call	0x292	; 0x292 <display>
	displaySpeed(1,0);
 492:	60 e0       	ldi	r22, 0x00	; 0
 494:	81 e0       	ldi	r24, 0x01	; 1
 496:	90 e0       	ldi	r25, 0x00	; 0
 498:	0e 94 1e 02 	call	0x43c	; 0x43c <displaySpeed>
	setSpeed(1,0);
 49c:	60 e0       	ldi	r22, 0x00	; 0
 49e:	81 e0       	ldi	r24, 0x01	; 1
 4a0:	90 e0       	ldi	r25, 0x00	; 0
 4a2:	0e 94 fd 00 	call	0x1fa	; 0x1fa <setSpeed>
 4a6:	81 ee       	ldi	r24, 0xE1	; 225
 4a8:	94 e0       	ldi	r25, 0x04	; 4
 4aa:	01 97       	sbiw	r24, 0x01	; 1
 4ac:	f1 f7       	brne	.-4      	; 0x4aa <startUp+0x24>
 4ae:	00 c0       	rjmp	.+0      	; 0x4b0 <startUp+0x2a>
 4b0:	00 00       	nop
	_delay_ms(5);
	
	display(-1);
 4b2:	8f ef       	ldi	r24, 0xFF	; 255
 4b4:	9f ef       	ldi	r25, 0xFF	; 255
 4b6:	0e 94 49 01 	call	0x292	; 0x292 <display>
 4ba:	81 ee       	ldi	r24, 0xE1	; 225
 4bc:	94 e0       	ldi	r25, 0x04	; 4
 4be:	01 97       	sbiw	r24, 0x01	; 1
 4c0:	f1 f7       	brne	.-4      	; 0x4be <startUp+0x38>
 4c2:	00 c0       	rjmp	.+0      	; 0x4c4 <startUp+0x3e>
 4c4:	00 00       	nop
	_delay_ms(5);
	
	for (int i = 1; i < 5; i++)
 4c6:	c1 e0       	ldi	r28, 0x01	; 1
 4c8:	d0 e0       	ldi	r29, 0x00	; 0
	{
		display(-2);
 4ca:	8e ef       	ldi	r24, 0xFE	; 254
 4cc:	9f ef       	ldi	r25, 0xFF	; 255
 4ce:	0e 94 49 01 	call	0x292	; 0x292 <display>
		displaySpeed(i,1);
 4d2:	61 e0       	ldi	r22, 0x01	; 1
 4d4:	ce 01       	movw	r24, r28
 4d6:	0e 94 1e 02 	call	0x43c	; 0x43c <displaySpeed>
		setSpeed(i,1);
 4da:	61 e0       	ldi	r22, 0x01	; 1
 4dc:	ce 01       	movw	r24, r28
 4de:	0e 94 fd 00 	call	0x1fa	; 0x1fa <setSpeed>
 4e2:	81 ee       	ldi	r24, 0xE1	; 225
 4e4:	94 e0       	ldi	r25, 0x04	; 4
 4e6:	01 97       	sbiw	r24, 0x01	; 1
 4e8:	f1 f7       	brne	.-4      	; 0x4e6 <startUp+0x60>
 4ea:	00 c0       	rjmp	.+0      	; 0x4ec <startUp+0x66>
 4ec:	00 00       	nop
		_delay_ms(5);
		
		display(-1);
 4ee:	8f ef       	ldi	r24, 0xFF	; 255
 4f0:	9f ef       	ldi	r25, 0xFF	; 255
 4f2:	0e 94 49 01 	call	0x292	; 0x292 <display>
 4f6:	81 ee       	ldi	r24, 0xE1	; 225
 4f8:	94 e0       	ldi	r25, 0x04	; 4
 4fa:	01 97       	sbiw	r24, 0x01	; 1
 4fc:	f1 f7       	brne	.-4      	; 0x4fa <startUp+0x74>
 4fe:	00 c0       	rjmp	.+0      	; 0x500 <startUp+0x7a>
 500:	00 00       	nop
	_delay_ms(5);
	
	display(-1);
	_delay_ms(5);
	
	for (int i = 1; i < 5; i++)
 502:	21 96       	adiw	r28, 0x01	; 1
 504:	c5 30       	cpi	r28, 0x05	; 5
 506:	d1 05       	cpc	r29, r1
 508:	01 f7       	brne	.-64     	; 0x4ca <startUp+0x44>
 50a:	c4 e0       	ldi	r28, 0x04	; 4
 50c:	d0 e0       	ldi	r29, 0x00	; 0
		display(-1);
		_delay_ms(5);
	}
	for (int i = 4; i > 0; i--)
	{
		display(-2);
 50e:	8e ef       	ldi	r24, 0xFE	; 254
 510:	9f ef       	ldi	r25, 0xFF	; 255
 512:	0e 94 49 01 	call	0x292	; 0x292 <display>
		displaySpeed(i,1);
 516:	61 e0       	ldi	r22, 0x01	; 1
 518:	ce 01       	movw	r24, r28
 51a:	0e 94 1e 02 	call	0x43c	; 0x43c <displaySpeed>
		setSpeed(i,1);
 51e:	61 e0       	ldi	r22, 0x01	; 1
 520:	ce 01       	movw	r24, r28
 522:	0e 94 fd 00 	call	0x1fa	; 0x1fa <setSpeed>
 526:	81 ee       	ldi	r24, 0xE1	; 225
 528:	94 e0       	ldi	r25, 0x04	; 4
 52a:	01 97       	sbiw	r24, 0x01	; 1
 52c:	f1 f7       	brne	.-4      	; 0x52a <startUp+0xa4>
 52e:	00 c0       	rjmp	.+0      	; 0x530 <startUp+0xaa>
 530:	00 00       	nop
		_delay_ms(5);
		
		display(-1);
 532:	8f ef       	ldi	r24, 0xFF	; 255
 534:	9f ef       	ldi	r25, 0xFF	; 255
 536:	0e 94 49 01 	call	0x292	; 0x292 <display>
 53a:	81 ee       	ldi	r24, 0xE1	; 225
 53c:	94 e0       	ldi	r25, 0x04	; 4
 53e:	01 97       	sbiw	r24, 0x01	; 1
 540:	f1 f7       	brne	.-4      	; 0x53e <startUp+0xb8>
 542:	00 c0       	rjmp	.+0      	; 0x544 <startUp+0xbe>
 544:	00 00       	nop
		_delay_ms(5);
		
		display(-1);
		_delay_ms(5);
	}
	for (int i = 4; i > 0; i--)
 546:	21 97       	sbiw	r28, 0x01	; 1
 548:	20 97       	sbiw	r28, 0x00	; 0
 54a:	09 f7       	brne	.-62     	; 0x50e <startUp+0x88>
		_delay_ms(5);
		
		display(-1);
		_delay_ms(5);
	}
}
 54c:	df 91       	pop	r29
 54e:	cf 91       	pop	r28
 550:	08 95       	ret

00000552 <main>:
void LEDisable(int LENumber);


int main(void)
{
	init();
 552:	0e 94 67 00 	call	0xce	; 0xce <init>
	startUp();
 556:	0e 94 43 02 	call	0x486	; 0x486 <startUp>
	for (int i = 1; i < 4; i++) LEEnabel(i);
 55a:	81 e0       	ldi	r24, 0x01	; 1
 55c:	90 e0       	ldi	r25, 0x00	; 0
 55e:	0e 94 27 01 	call	0x24e	; 0x24e <LEEnabel>
 562:	82 e0       	ldi	r24, 0x02	; 2
 564:	90 e0       	ldi	r25, 0x00	; 0
 566:	0e 94 27 01 	call	0x24e	; 0x24e <LEEnabel>
 56a:	83 e0       	ldi	r24, 0x03	; 3
 56c:	90 e0       	ldi	r25, 0x00	; 0
 56e:	0e 94 27 01 	call	0x24e	; 0x24e <LEEnabel>
	while (1)
	{
		fireMode = getFireMode();
 572:	c1 e0       	ldi	r28, 0x01	; 1
 574:	d0 e0       	ldi	r29, 0x00	; 0
		}
		
		if(((newMag == 0) & !(newMagSize == -1)))		//Mag-slot not empty anymore 
		{
			ammoCounter = newMagSize;
			newMag = 1;
 576:	99 24       	eor	r9, r9
 578:	93 94       	inc	r9
		fireMode = getFireMode();
		newMagSize = getMag();			//save the Mag size 
		if(newMagSize == -1) 
		{
			newMag = 0;					//Mag-slot empty 
			ammoCounter = -1;
 57a:	0f ef       	ldi	r16, 0xFF	; 255
 57c:	1f ef       	ldi	r17, 0xFF	; 255
			newMag = 1;
		}
		if(adcOn == 0)		display(ammoCounter);
		if(adcOn == 1)		
		{
			volt |= (ADCL);
 57e:	0f 2e       	mov	r0, r31
 580:	f8 e7       	ldi	r31, 0x78	; 120
 582:	af 2e       	mov	r10, r31
 584:	b1 2c       	mov	r11, r1
 586:	f0 2d       	mov	r31, r0
			volt |= (ADCH << 8);
 588:	0f 2e       	mov	r0, r31
 58a:	f9 e7       	ldi	r31, 0x79	; 121
 58c:	cf 2e       	mov	r12, r31
 58e:	d1 2c       	mov	r13, r1
 590:	f0 2d       	mov	r31, r0
 			volt = volt *15;
 592:	0f 2e       	mov	r0, r31
 594:	ff e0       	ldi	r31, 0x0F	; 15
 596:	8f 2e       	mov	r8, r31
 598:	f0 2d       	mov	r31, r0
			volt = volt /1023;
 59a:	0f 2e       	mov	r0, r31
 59c:	ee 24       	eor	r14, r14
 59e:	ea 94       	dec	r14
 5a0:	f3 e0       	ldi	r31, 0x03	; 3
 5a2:	ff 2e       	mov	r15, r31
 5a4:	f0 2d       	mov	r31, r0
	init();
	startUp();
	for (int i = 1; i < 4; i++) LEEnabel(i);
	while (1)
	{
		fireMode = getFireMode();
 5a6:	d0 93 0a 01 	sts	0x010A, r29
 5aa:	c0 93 09 01 	sts	0x0109, r28
		newMagSize = getMag();			//save the Mag size 
 5ae:	0e 94 b9 00 	call	0x172	; 0x172 <getMag>
 5b2:	90 93 0e 01 	sts	0x010E, r25
 5b6:	80 93 0d 01 	sts	0x010D, r24
		if(newMagSize == -1) 
 5ba:	8f 3f       	cpi	r24, 0xFF	; 255
 5bc:	2f ef       	ldi	r18, 0xFF	; 255
 5be:	92 07       	cpc	r25, r18
 5c0:	39 f4       	brne	.+14     	; 0x5d0 <main+0x7e>
		{
			newMag = 0;					//Mag-slot empty 
 5c2:	10 92 03 01 	sts	0x0103, r1
			ammoCounter = -1;
 5c6:	10 93 0c 01 	sts	0x010C, r17
 5ca:	00 93 0b 01 	sts	0x010B, r16
 5ce:	0a c0       	rjmp	.+20     	; 0x5e4 <main+0x92>
		}
		
		if(((newMag == 0) & !(newMagSize == -1)))		//Mag-slot not empty anymore 
 5d0:	20 91 03 01 	lds	r18, 0x0103
 5d4:	21 11       	cpse	r18, r1
 5d6:	06 c0       	rjmp	.+12     	; 0x5e4 <main+0x92>
		{
			ammoCounter = newMagSize;
 5d8:	90 93 0c 01 	sts	0x010C, r25
 5dc:	80 93 0b 01 	sts	0x010B, r24
			newMag = 1;
 5e0:	90 92 03 01 	sts	0x0103, r9
		}
		if(adcOn == 0)		display(ammoCounter);
 5e4:	80 91 06 01 	lds	r24, 0x0106
 5e8:	90 91 07 01 	lds	r25, 0x0107
 5ec:	89 2b       	or	r24, r25
 5ee:	31 f4       	brne	.+12     	; 0x5fc <main+0xaa>
 5f0:	80 91 0b 01 	lds	r24, 0x010B
 5f4:	90 91 0c 01 	lds	r25, 0x010C
 5f8:	0e 94 49 01 	call	0x292	; 0x292 <display>
		if(adcOn == 1)		
 5fc:	80 91 06 01 	lds	r24, 0x0106
 600:	90 91 07 01 	lds	r25, 0x0107
 604:	01 97       	sbiw	r24, 0x01	; 1
 606:	f1 f4       	brne	.+60     	; 0x644 <main+0xf2>
		{
			volt |= (ADCL);
 608:	f5 01       	movw	r30, r10
 60a:	20 81       	ld	r18, Z
 60c:	80 91 04 01 	lds	r24, 0x0104
 610:	90 91 05 01 	lds	r25, 0x0105
 614:	82 2b       	or	r24, r18
 616:	90 93 05 01 	sts	0x0105, r25
 61a:	80 93 04 01 	sts	0x0104, r24
			volt |= (ADCH << 8);
 61e:	f6 01       	movw	r30, r12
 620:	20 81       	ld	r18, Z
 622:	ac 01       	movw	r20, r24
 624:	52 2b       	or	r21, r18
 			volt = volt *15;
 626:	84 9e       	mul	r8, r20
 628:	c0 01       	movw	r24, r0
 62a:	85 9e       	mul	r8, r21
 62c:	90 0d       	add	r25, r0
 62e:	11 24       	eor	r1, r1
			volt = volt /1023;
 630:	b7 01       	movw	r22, r14
 632:	0e 94 1d 04 	call	0x83a	; 0x83a <__udivmodhi4>
 636:	cb 01       	movw	r24, r22
 638:	70 93 05 01 	sts	0x0105, r23
 63c:	60 93 04 01 	sts	0x0104, r22
 			display(volt);
 640:	0e 94 49 01 	call	0x292	; 0x292 <display>
		}
		displaySpeed(speed, motorOn);
 644:	60 91 00 01 	lds	r22, 0x0100
 648:	80 91 01 01 	lds	r24, 0x0101
 64c:	90 91 02 01 	lds	r25, 0x0102
 650:	0e 94 1e 02 	call	0x43c	; 0x43c <displaySpeed>
		setSpeed(speed, motorOn);
 654:	60 91 00 01 	lds	r22, 0x0100
 658:	80 91 01 01 	lds	r24, 0x0101
 65c:	90 91 02 01 	lds	r25, 0x0102
 660:	0e 94 fd 00 	call	0x1fa	; 0x1fa <setSpeed>
	}
 664:	a0 cf       	rjmp	.-192    	; 0x5a6 <main+0x54>

00000666 <__vector_1>:
	if (LENumber == 3)	PORTA |= (1 << PORTA6);
	_delay_ms(25);
}

ISR(INT0_vect)
{
 666:	1f 92       	push	r1
 668:	0f 92       	push	r0
 66a:	0f b6       	in	r0, 0x3f	; 63
 66c:	0f 92       	push	r0
 66e:	11 24       	eor	r1, r1
 670:	8f 93       	push	r24
 672:	ef 93       	push	r30
 674:	ff 93       	push	r31
	if (fire == 0 && motorOn == 1)
 676:	80 91 08 01 	lds	r24, 0x0108
 67a:	81 11       	cpse	r24, r1
 67c:	16 c0       	rjmp	.+44     	; 0x6aa <__vector_1+0x44>
 67e:	80 91 00 01 	lds	r24, 0x0100
 682:	81 30       	cpi	r24, 0x01	; 1
 684:	91 f4       	brne	.+36     	; 0x6aa <__vector_1+0x44>
	{
		fire = 1;
 686:	80 93 08 01 	sts	0x0108, r24
		EICRA |= (1 << ISC00);				//sets INT0 to rising edge
 68a:	e9 e6       	ldi	r30, 0x69	; 105
 68c:	f0 e0       	ldi	r31, 0x00	; 0
 68e:	80 81       	ld	r24, Z
 690:	81 60       	ori	r24, 0x01	; 1
 692:	80 83       	st	Z, r24
		TCCR2A |= (1 << COM2A1);			//select the Output Pin	for PWM
 694:	e0 eb       	ldi	r30, 0xB0	; 176
 696:	f0 e0       	ldi	r31, 0x00	; 0
 698:	80 81       	ld	r24, Z
 69a:	80 68       	ori	r24, 0x80	; 128
 69c:	80 83       	st	Z, r24
		TCCR2B |= (1 << CS20);				//activates PWM 
 69e:	e1 eb       	ldi	r30, 0xB1	; 177
 6a0:	f0 e0       	ldi	r31, 0x00	; 0
 6a2:	80 81       	ld	r24, Z
 6a4:	81 60       	ori	r24, 0x01	; 1
 6a6:	80 83       	st	Z, r24
 6a8:	15 c0       	rjmp	.+42     	; 0x6d4 <__vector_1+0x6e>
	}
	else if (fire == 1)
 6aa:	80 91 08 01 	lds	r24, 0x0108
 6ae:	81 30       	cpi	r24, 0x01	; 1
 6b0:	89 f4       	brne	.+34     	; 0x6d4 <__vector_1+0x6e>
	{
		fire = 0;
 6b2:	10 92 08 01 	sts	0x0108, r1
		EICRA &= ~(1 << ISC00);				//sets INT0 to falling edge
 6b6:	e9 e6       	ldi	r30, 0x69	; 105
 6b8:	f0 e0       	ldi	r31, 0x00	; 0
 6ba:	80 81       	ld	r24, Z
 6bc:	8e 7f       	andi	r24, 0xFE	; 254
 6be:	80 83       	st	Z, r24
		TCCR2A &= ~(1 << COM2A1);			//select the Output Pin	for PWM
 6c0:	e0 eb       	ldi	r30, 0xB0	; 176
 6c2:	f0 e0       	ldi	r31, 0x00	; 0
 6c4:	80 81       	ld	r24, Z
 6c6:	8f 77       	andi	r24, 0x7F	; 127
 6c8:	80 83       	st	Z, r24
		TCCR2B &= ~(1 << CS20);				//deactivates PWM
 6ca:	e1 eb       	ldi	r30, 0xB1	; 177
 6cc:	f0 e0       	ldi	r31, 0x00	; 0
 6ce:	80 81       	ld	r24, Z
 6d0:	8e 7f       	andi	r24, 0xFE	; 254
 6d2:	80 83       	st	Z, r24
	}
}
 6d4:	ff 91       	pop	r31
 6d6:	ef 91       	pop	r30
 6d8:	8f 91       	pop	r24
 6da:	0f 90       	pop	r0
 6dc:	0f be       	out	0x3f, r0	; 63
 6de:	0f 90       	pop	r0
 6e0:	1f 90       	pop	r1
 6e2:	18 95       	reti

000006e4 <__vector_2>:
ISR(INT1_vect)
{
 6e4:	1f 92       	push	r1
 6e6:	0f 92       	push	r0
 6e8:	0f b6       	in	r0, 0x3f	; 63
 6ea:	0f 92       	push	r0
 6ec:	11 24       	eor	r1, r1
 6ee:	8f 93       	push	r24
 6f0:	9f 93       	push	r25
 6f2:	ef 93       	push	r30
 6f4:	ff 93       	push	r31
	if(adcOn == 0)
 6f6:	80 91 06 01 	lds	r24, 0x0106
 6fa:	90 91 07 01 	lds	r25, 0x0107
 6fe:	89 2b       	or	r24, r25
 700:	89 f4       	brne	.+34     	; 0x724 <__vector_2+0x40>
	{
		adcOn = 1;
 702:	81 e0       	ldi	r24, 0x01	; 1
 704:	90 e0       	ldi	r25, 0x00	; 0
 706:	90 93 07 01 	sts	0x0107, r25
 70a:	80 93 06 01 	sts	0x0106, r24
		EICRA |= (1 << ISC10);				//sets INT1 to rising edge
 70e:	e9 e6       	ldi	r30, 0x69	; 105
 710:	f0 e0       	ldi	r31, 0x00	; 0
 712:	80 81       	ld	r24, Z
 714:	84 60       	ori	r24, 0x04	; 4
 716:	80 83       	st	Z, r24
		ADCSRA |= (1 << ADSC);				//activates the ADC for 1 conversion
 718:	ea e7       	ldi	r30, 0x7A	; 122
 71a:	f0 e0       	ldi	r31, 0x00	; 0
 71c:	80 81       	ld	r24, Z
 71e:	80 64       	ori	r24, 0x40	; 64
 720:	80 83       	st	Z, r24
 722:	14 c0       	rjmp	.+40     	; 0x74c <__vector_2+0x68>
	}
	else if(adcOn == 1)
 724:	80 91 06 01 	lds	r24, 0x0106
 728:	90 91 07 01 	lds	r25, 0x0107
 72c:	01 97       	sbiw	r24, 0x01	; 1
 72e:	51 f4       	brne	.+20     	; 0x744 <__vector_2+0x60>
	{
		adcOn = 0;
 730:	10 92 07 01 	sts	0x0107, r1
 734:	10 92 06 01 	sts	0x0106, r1
		EICRA &= ~(1 << ISC10);				//returns INT1 to falling edge
 738:	e9 e6       	ldi	r30, 0x69	; 105
 73a:	f0 e0       	ldi	r31, 0x00	; 0
 73c:	80 81       	ld	r24, Z
 73e:	8b 7f       	andi	r24, 0xFB	; 251
 740:	80 83       	st	Z, r24
 742:	04 c0       	rjmp	.+8      	; 0x74c <__vector_2+0x68>
	}
	else adcOn = 0;
 744:	10 92 07 01 	sts	0x0107, r1
 748:	10 92 06 01 	sts	0x0106, r1

}
 74c:	ff 91       	pop	r31
 74e:	ef 91       	pop	r30
 750:	9f 91       	pop	r25
 752:	8f 91       	pop	r24
 754:	0f 90       	pop	r0
 756:	0f be       	out	0x3f, r0	; 63
 758:	0f 90       	pop	r0
 75a:	1f 90       	pop	r1
 75c:	18 95       	reti

0000075e <__vector_4>:

ISR(PCINT0_vect)
{ 
 75e:	1f 92       	push	r1
 760:	0f 92       	push	r0
 762:	0f b6       	in	r0, 0x3f	; 63
 764:	0f 92       	push	r0
 766:	11 24       	eor	r1, r1
 768:	8f 93       	push	r24
 76a:	9f 93       	push	r25
	if(!(PINA & (1<<PINA0)))			//Increases motor speed
 76c:	00 99       	sbic	0x00, 0	; 0
 76e:	0f c0       	rjmp	.+30     	; 0x78e <__vector_4+0x30>
	{
		if (speed < 4)	speed++;
 770:	80 91 01 01 	lds	r24, 0x0101
 774:	90 91 02 01 	lds	r25, 0x0102
 778:	04 97       	sbiw	r24, 0x04	; 4
 77a:	4c f4       	brge	.+18     	; 0x78e <__vector_4+0x30>
 77c:	80 91 01 01 	lds	r24, 0x0101
 780:	90 91 02 01 	lds	r25, 0x0102
 784:	01 96       	adiw	r24, 0x01	; 1
 786:	90 93 02 01 	sts	0x0102, r25
 78a:	80 93 01 01 	sts	0x0101, r24
	}
	if(!(PINA & (1<<PINA1)))			//Reduces motor speed
 78e:	01 99       	sbic	0x00, 1	; 0
 790:	0f c0       	rjmp	.+30     	; 0x7b0 <__vector_4+0x52>
	{
		if(speed > 1)	speed--;
 792:	80 91 01 01 	lds	r24, 0x0101
 796:	90 91 02 01 	lds	r25, 0x0102
 79a:	02 97       	sbiw	r24, 0x02	; 2
 79c:	4c f0       	brlt	.+18     	; 0x7b0 <__vector_4+0x52>
 79e:	80 91 01 01 	lds	r24, 0x0101
 7a2:	90 91 02 01 	lds	r25, 0x0102
 7a6:	01 97       	sbiw	r24, 0x01	; 1
 7a8:	90 93 02 01 	sts	0x0102, r25
 7ac:	80 93 01 01 	sts	0x0101, r24
	}
	if(!(PINA & (1<<PINA2)))			//turns motor on and off
 7b0:	02 99       	sbic	0x00, 2	; 0
 7b2:	0e c0       	rjmp	.+28     	; 0x7d0 <__vector_4+0x72>
	{
		if(motorOn == 0) motorOn = 1;
 7b4:	80 91 00 01 	lds	r24, 0x0100
 7b8:	81 11       	cpse	r24, r1
 7ba:	04 c0       	rjmp	.+8      	; 0x7c4 <__vector_4+0x66>
 7bc:	81 e0       	ldi	r24, 0x01	; 1
 7be:	80 93 00 01 	sts	0x0100, r24
 7c2:	06 c0       	rjmp	.+12     	; 0x7d0 <__vector_4+0x72>
		else if(motorOn == 1) motorOn = 0;
 7c4:	80 91 00 01 	lds	r24, 0x0100
 7c8:	81 30       	cpi	r24, 0x01	; 1
 7ca:	11 f4       	brne	.+4      	; 0x7d0 <__vector_4+0x72>
 7cc:	10 92 00 01 	sts	0x0100, r1
	}
}
 7d0:	9f 91       	pop	r25
 7d2:	8f 91       	pop	r24
 7d4:	0f 90       	pop	r0
 7d6:	0f be       	out	0x3f, r0	; 63
 7d8:	0f 90       	pop	r0
 7da:	1f 90       	pop	r1
 7dc:	18 95       	reti

000007de <__vector_6>:
ISR(PCINT2_vect)
{
 7de:	1f 92       	push	r1
 7e0:	0f 92       	push	r0
 7e2:	0f b6       	in	r0, 0x3f	; 63
 7e4:	0f 92       	push	r0
 7e6:	11 24       	eor	r1, r1
 7e8:	8f 93       	push	r24
 7ea:	9f 93       	push	r25
	if(!(PINC & (1<<PINC7)))			//checks if something passes the light barrier
 7ec:	37 99       	sbic	0x06, 7	; 6
 7ee:	1e c0       	rjmp	.+60     	; 0x82c <__vector_6+0x4e>
	{
		if(ammoCounter > 0)	ammoCounter--;
 7f0:	80 91 0b 01 	lds	r24, 0x010B
 7f4:	90 91 0c 01 	lds	r25, 0x010C
 7f8:	18 16       	cp	r1, r24
 7fa:	19 06       	cpc	r1, r25
 7fc:	4c f4       	brge	.+18     	; 0x810 <__vector_6+0x32>
 7fe:	80 91 0b 01 	lds	r24, 0x010B
 802:	90 91 0c 01 	lds	r25, 0x010C
 806:	01 97       	sbiw	r24, 0x01	; 1
 808:	90 93 0c 01 	sts	0x010C, r25
 80c:	80 93 0b 01 	sts	0x010B, r24
		PORTC ^= 1 << PINC0;
 810:	98 b1       	in	r25, 0x08	; 8
 812:	81 e0       	ldi	r24, 0x01	; 1
 814:	89 27       	eor	r24, r25
 816:	88 b9       	out	0x08, r24	; 8
 818:	89 e6       	ldi	r24, 0x69	; 105
 81a:	98 e1       	ldi	r25, 0x18	; 24
 81c:	01 97       	sbiw	r24, 0x01	; 1
 81e:	f1 f7       	brne	.-4      	; 0x81c <__vector_6+0x3e>
 820:	00 c0       	rjmp	.+0      	; 0x822 <__vector_6+0x44>
 822:	00 00       	nop
		_delay_ms(25);
		PORTC ^= 1 << PINC0;
 824:	98 b1       	in	r25, 0x08	; 8
 826:	81 e0       	ldi	r24, 0x01	; 1
 828:	89 27       	eor	r24, r25
 82a:	88 b9       	out	0x08, r24	; 8
	}
	
}
 82c:	9f 91       	pop	r25
 82e:	8f 91       	pop	r24
 830:	0f 90       	pop	r0
 832:	0f be       	out	0x3f, r0	; 63
 834:	0f 90       	pop	r0
 836:	1f 90       	pop	r1
 838:	18 95       	reti

0000083a <__udivmodhi4>:
 83a:	aa 1b       	sub	r26, r26
 83c:	bb 1b       	sub	r27, r27
 83e:	51 e1       	ldi	r21, 0x11	; 17
 840:	07 c0       	rjmp	.+14     	; 0x850 <__udivmodhi4_ep>

00000842 <__udivmodhi4_loop>:
 842:	aa 1f       	adc	r26, r26
 844:	bb 1f       	adc	r27, r27
 846:	a6 17       	cp	r26, r22
 848:	b7 07       	cpc	r27, r23
 84a:	10 f0       	brcs	.+4      	; 0x850 <__udivmodhi4_ep>
 84c:	a6 1b       	sub	r26, r22
 84e:	b7 0b       	sbc	r27, r23

00000850 <__udivmodhi4_ep>:
 850:	88 1f       	adc	r24, r24
 852:	99 1f       	adc	r25, r25
 854:	5a 95       	dec	r21
 856:	a9 f7       	brne	.-22     	; 0x842 <__udivmodhi4_loop>
 858:	80 95       	com	r24
 85a:	90 95       	com	r25
 85c:	bc 01       	movw	r22, r24
 85e:	cd 01       	movw	r24, r26
 860:	08 95       	ret

00000862 <__tablejump2__>:
 862:	ee 0f       	add	r30, r30
 864:	ff 1f       	adc	r31, r31

00000866 <__tablejump__>:
 866:	05 90       	lpm	r0, Z+
 868:	f4 91       	lpm	r31, Z
 86a:	e0 2d       	mov	r30, r0
 86c:	09 94       	ijmp

0000086e <_exit>:
 86e:	f8 94       	cli

00000870 <__stop_program>:
 870:	ff cf       	rjmp	.-2      	; 0x870 <__stop_program>
